<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Added user-scalable=no for better mobile experience -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <title>baettig.dev</title>
    <meta name="description" content="Personal website of yoggu" />
    <meta name="keywords" content="baettig, dev, portfolio, javascript" />
    <meta name="author" content="yoggu" />
    <meta name="robots" content="index, follow" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        overscroll-behavior: none;
      }
      canvas {
        display: block;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const text = "baettig.dev";
      let fontSize = Math.min(window.innerWidth / 8, 100);
      let particles = [];

      let interactionPoint = {
        x: null,
        y: null,
        // --- CHANGE 1: Increased interaction radius ---
        radius: 100, // Was 60, now particles are affected from further away
      };

      function createParticles() {
        particles = [];
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;

        tempCtx.fillStyle = "white";
        tempCtx.font = `bold ${fontSize}px Arial`;
        tempCtx.textAlign = "center";
        tempCtx.textBaseline = "middle";
        tempCtx.fillText(text, canvas.width / 2, canvas.height / 2);

        const imageData = tempCtx.getImageData(
          0,
          0,
          canvas.width,
          canvas.height
        );
        const data = imageData.data;
        const density = 4;

        for (let y = 0; y < canvas.height; y += density) {
          for (let x = 0; x < canvas.width; x += density) {
            const index = (y * canvas.width + x) * 4;
            if (data[index + 3] > 128) {
              particles.push(new Particle(x, y));
            }
          }
        }
      }

      class Particle {
        constructor(x, y) {
          this.x = x + (Math.random() - 0.5) * 5;
          this.y = y + (Math.random() - 0.5) * 5;
          this.baseX = x;
          this.baseY = y;
          this.vx = 0;
          this.vy = 0;
          // --- CHANGE 2: Increased density/base push strength ---
          this.density = Math.random() * 20 + 15; // Was Math.random() * 10 + 5
          this.alpha = 1;
          this.friction = 0.95; // Keep friction for now, adjust if needed
          // --- CHANGE 3: Decreased return force ---
          this.returnForce = 0.01 + Math.random() * 0.015; // Was 0.02 + Math.random() * 0.03
          // --- CHANGE 4: Slightly increased push multiplier ---
          this.pushForceMultiplier = 1.2 + Math.random() * 0.6; // Was 1 + Math.random() * 0.5
        }

        update(interaction) {
          let dxInteraction = 0;
          let dyInteraction = 0;
          let distanceInteraction = Infinity;

          if (interaction.x !== null && interaction.y !== null) {
            dxInteraction = this.x - interaction.x;
            dyInteraction = this.y - interaction.y;
            distanceInteraction = Math.sqrt(
              dxInteraction ** 2 + dyInteraction ** 2
            );

            if (
              distanceInteraction < interaction.radius &&
              distanceInteraction > 0 // Avoid division by zero if distance is exactly 0
            ) {
              // Force calculation remains structurally the same, but the inputs (density, multiplier) are larger
              const force =
                ((interaction.radius - distanceInteraction) /
                  interaction.radius) * // Strength based on proximity
                this.density * // Now stronger base push
                this.pushForceMultiplier; // Now slightly higher multiplier

              // Apply the calculated force to velocity
              this.vx += (dxInteraction / distanceInteraction) * force;
              this.vy += (dyInteraction / distanceInteraction) * force;
            }
          }

          // --- Return to Base Calculation (weaker now due to smaller returnForce) ---
          const dxBase = this.baseX - this.x;
          const dyBase = this.baseY - this.y;
          this.vx += dxBase * this.returnForce;
          this.vy += dyBase * this.returnForce;

          // --- Apply Friction & Update Position ---
          this.vx *= this.friction;
          this.vy *= this.friction;

          this.x += this.vx;
          this.y += this.vy;

          // --- Fade near edges ---
          const fadeMargin = 50;
          let targetAlpha = 1; // Assume full alpha initially
          if (this.x < fadeMargin) targetAlpha = this.x / fadeMargin;
          else if (this.x > canvas.width - fadeMargin)
            targetAlpha = (canvas.width - this.x) / fadeMargin;
          else if (this.y < fadeMargin) targetAlpha = this.y / fadeMargin;
          else if (this.y > canvas.height - fadeMargin)
            targetAlpha = (canvas.height - this.y) / fadeMargin;

          // Smoothly transition alpha instead of abrupt change
          this.alpha += (Math.max(0, targetAlpha) - this.alpha) * 0.1; // Approach target alpha gradually
          if (this.alpha > 1) this.alpha = 1; // Clamp alpha
        }

        draw() {
          if (
            this.alpha <= 0.01 ||
            this.x < 0 ||
            this.x > canvas.width ||
            this.y < 0 ||
            this.y > canvas.height
          ) {
            return;
          }
          ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // --- Event Listeners ---
      function updateInteractionPoint(x, y) {
        interactionPoint.x = x;
        interactionPoint.y = y;
      }

      function clearInteractionPoint() {
        interactionPoint.x = null;
        interactionPoint.y = null;
      }

      canvas.addEventListener("mousemove", (e) => {
        updateInteractionPoint(e.clientX, e.clientY);
      });
      canvas.addEventListener("mouseout", () => {
        clearInteractionPoint();
      });
      canvas.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length > 0) {
            updateInteractionPoint(e.touches[0].clientX, e.touches[0].clientY);
          }
        },
        { passive: false }
      );
      canvas.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          if (e.touches.length > 0) {
            updateInteractionPoint(e.touches[0].clientX, e.touches[0].clientY);
          }
        },
        { passive: false }
      );
      canvas.addEventListener("touchend", () => {
        clearInteractionPoint();
      });
      canvas.addEventListener("touchcancel", () => {
        clearInteractionPoint();
      });

      // --- Animation Loop ---
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < particles.length; i++) {
          particles[i].update(interactionPoint);
          particles[i].draw();
        }
        requestAnimationFrame(animate);
      }

      // --- Responsive Canvas ---
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        fontSize = Math.min(window.innerWidth / 8, 100);
        createParticles();
      }
      window.addEventListener("resize", resizeCanvas);

      // --- Initial Setup ---
      createParticles();
      animate();
    </script>
  </body>
</html>
